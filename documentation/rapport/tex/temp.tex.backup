



\subsubsection{Fin de traitement d'un message}
Le diagramme UML correspondant étant trop grand, nous ne l'avons pas inclus dans le rapport. Il est disponible dans le dossier \textbf{UML} qui accompagne le rapport (le fichier: \textbf{Evenement - HoteFinTraitementMessage.png}).




\subsubsection{Timeout}

\begin{figure}[h!t]
  \centering
    \includegraphics[scale=0.60]{HoteTimeoutReceptionAccuse}
  \caption{Timeout de réception d'un accusé}
  \label{fig:hote-timeout}
\end{figure}

TODO



\subsection{Agents}


\subsubsection{Réception d'un message}\label{evt-agent-reception-message}
Le diagramme UML correspondant étant trop grand, nous ne l'avons pas inclus dans le rapport. Il est disponible dans le dossier \textbf{UML} qui accompagne le rapport (le fichier: \textbf{Evenement - AgentRecoitMessage.png}).

Dans le diagramme UML, il y a deux points que nous n'avons pas expliqués:

\begin{itemize}
 \item Tout d'abord: \og Est-ce qu'on peut envoyer les nouvelles informations de routage maintenant? \fg. En fait nous avons décidé d'éviter trop d'envois successifs inutiles d'informations de routage, afin de ne pas surcharger le système. Pour ce faire, quand on doit envoyer les informations de routage (à cause du niveau d'occupation du buffer), on vérifie si ça fait au moins $x$ temps de simulation qu'on a envoyé un message. Si oui, alors on peut envoyer le message. De cette manière, si pour un temps $t$ donné, l'agent reçoit $50$ messages, que pour le premier il dépasse le seuil d'alerte d'occupation du buffer et envoie ses informations de routage, puisqu'il sera toujours au delà du seuil d'alerte pour les $49$ autres messages, on évite ainsi de réenvoyer les informations inutilement.
 
 \item Le second point: \og Augmentation du coût de nos routes à destination des autres agents (on augmente d'une valeur fixe à chaque fois) \fg. Nous faisons ceci avec que le distance vector prenne en compte le niveau d'occupation des agents. Quand un agent donné est surchargé, il augmente le coût de ses routes à destination des autres agents et prévient ses voisins. De cette manière quand les voisins reçoivent les informations, ils mettent à jour leur propre table de routage et choisissent peut être d'autres routes (i.e., changent leur DV) pour faire suivre les messages. Si les autres agents deviennent surchargés, leurs coûts augmenteront également. Ainsi au final, le DV prend en compte l'occupation des buffers des agents, ce qui permet de mieux répartir la charge sur les différents agents. Dans les résultats des simulations, nous avons en effet constaté que les buffers sont utilisés de manière plus homogène.
\end{itemize}





\subsubsection{Fin de traitement d'un message}
Le diagramme UML correspondant étant trop grand, nous ne l'avons pas inclus dans le rapport. Il est disponible dans le dossier \textbf{UML} qui accompagne le rapport (le fichier: \textbf{Evenement - AgentFinTraitementMessage.png}).









\subsubsection{Envoi des informations de routage}
\begin{figure}[h!t]
  \centering
    \includegraphics[scale=0.60]{AgentEnvoieInfosRoutage}
  \caption{Envoi d'informations de routage par un agent}
  \label{fig:agent-envoi-infos-routage}
\end{figure}

TODO



\subsubsection{Réception d'informations de routage}

\begin{figure}[h!t]
  \centering
    \includegraphics[scale=0.60]{AgentRecoitInfosRoutage}
  \caption{Réception d'informations de routage par un agent}
  \label{fig:agent-recoit-infos-routage}
\end{figure}

TODO




\subsection{Autres}

\subsubsection{Fin de simulation}
Le dernier évènement est spécial et est celui qui provoque la fin de la simulation. Quand cet évènement est l'évènement imminent, il remet la FEL à zéro (il n'y a donc plus d'évènement imminent) et la boucle de simulation s'arrête.


\begin{figure}[h!t]
  \centering
    \includegraphics[scale=0.60]{FinDeSimulation}
  \caption{Fin de la simulation}
  \label{fig:fin-de-simulation}
\end{figure}











\section{Paramètres du système}

\subsection{Hote}
\begin{itemize}
 \item Durée du timeout (temps après lequel on réémet un message)
 \item Temps maximal inter-envois (pour les messages originaux)
 \item Temps de traitement d'un message
 \item Pourcentage de messages à destination d'un autre agent
\end{itemize}


\subsection{Agent}

\begin{itemize}
 \item Nombre d'hôtes reliés
 \item Taux de pertes brutales de messages
 \item Temps de traitement d'un message
 \item Taille de buffer (en entrée)
\end{itemize}

Pour le distance vector on a en plus:
\begin{itemize}
 \item Temps inter-envois des informations de routage
\end{itemize}

\subsection{Simulation}
\begin{itemize}
 \item Durée
 \item Délai agent <-> hôte
 \item Distance vector activé (oui/non)
 \item Durée de la période d'initialisation
 \item Périodicité d'affichage des statistiques (e.g., tous les 1\% de simulation)
\end{itemize}




\section{Décisions}

\subsection{Gestion des évènements}
Nous avons choisi d'utiliser une seule FEL pour la simulation. On y place tous les évènements. De plus, pour un temps $t$ de simulation donné, nous avons décidé de traiter certains évènements prioritairement:

\begin{enumerate}
 \item En premier lieu on traite les évènements de réception d'informations de routage
 \item Puis les évènements de réception d'informations de routage
 \item Puis les évènements de réception de messages (accusés et messages normaux)
 \item Puis les évènements de timeout (un message pour lequel on a pas encore reçu d'accusé)
\end{enumerate}

Une fois tous ces évènements traités pour un temps $t$, on traite les autres selon l'ordre \textit{FIFO}.

\subsection{Distance vector}
Nous avons choisi de modifier les coûts en fonction du taux d'occupation du buffer de l'agent. Ceci est expliqué à la section \refp{evt-agent-reception-message} concernant l'évènement de réception d'un message par un agent.

Nous avons aussi implémenté la technique du \textit{poisonned reverse} comme expliqué dans l'article concernant le distance vector.




%\pagebreak
\clearpage

%\backmatter % pour ne pas numéroter à la fin
\input{annexes}
\appendix
